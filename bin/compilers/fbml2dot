#!env python
"""
.. program:: fbml2dot
.. codeauthor:: Christian Gram Kalhauge <kalhauge@cbs.dtu.dk>


"""
import os
import logging
log = logging.getLogger('fbml2dot')

import fbml
import fbml.core
from fbml.parsers.xmlformat import XMLParser
from fbml.structure import Label


def main(args):
    builder = fbml.get_builder(paths=[os.getcwd()],extensions=['method_name']) 
    method = builder.label_from_string(args.methodid).get()
    if not isinstance(method,fbml.model.Method):
        log.error("%s is not a Method, it's a: %r",args.methodid,method)
        return -1
    method_to_dot(method, sys.stdout)
       
    return 0

def id_(obj): return obj.label.name


def method_to_dot(method, filelike):
    filelike.write("digraph {\n")
    filelike.write( "  node [shape=record,style=rounded,height=0.1];\n")
    filelike.write('  ' + '\n  '.join(DotVisitor().visit(method)) + "\n")
    filelike.write("}\n")

class DotVisitor (fbml.ControlFlowVisitor):

    def __init__(self):
        super(DotVisitor,self).__init__()
    
    def setup(self,method):
        """
        Setup initializes the list of lines which everythis is appended to
        """
        dotlines = []
        dotlines.append('"{}" [label="{}"]'.format(
                id_(method),
                self.function_to_dot_label(
                    [],
                    method.sources,
                    method.req.method_name,
                    )
                )
            )
        return dotlines 

    def final(self,method,dotlines):
        for sink in method.targets:
            dotlines.append('OUT_{} [label = "{}"];'.format(
                id_(sink),id_(sink)))
            dotlines.append('"{}":{} -> "OUT_{}";'.format(
                id_(sink.owner), id_(sink), id_(sink)))
        return dotlines

    def apply(self,function,dotlines):
        function_str= '{} [label="{}"];'.format(
            function.label.name,
            self.function_to_dot_label(
                function.sources, 
                function.targets,
                function.ext.method_name
                )
            )
        
        connections = []
        for sink in function.sources:
            con = '"{}":{} -> "{}":{};'.format(
                    id_(sink.owner),
                    id_(sink),
                    id_(function),
                    id_(sink)
                )
            connections.append(con);
        dotlines.append(function_str)
        dotlines.extend(connections)

        return dotlines

    def function_to_dot_label(self, sources, targets, method_name):
        in_str  = "|".join(["<{s_id}> {s_id}".format(s_id=id_(s)) 
            for s in sorted(sources,key=id_)]);
        out_str = "|".join(["<{s_id}> {s_id}".format(s_id=id_(s)) 
            for s in sorted(targets,key=id_)]);

        in_label = '{{{}}} |'.format(in_str) if sources else ''
        out_label = '| {{{}}}'.format(out_str) if targets else ''

        label =' '.join(str(x) for x in ['{',in_label, method_name, out_label,'}'])

        return label
        

        
def parse_args():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('methodid',help='the fullpath id of the method');

    args = parser.parse_args()
    # Post processing of args
    return args

if __name__ == '__main__':
    import sys
    logging.basicConfig(level=logging.INFO)
    sys.exit(main(parse_args()))

